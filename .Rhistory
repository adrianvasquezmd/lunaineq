)
} else if (rci_est < 0 & health_indicator_type == "proportion") {
paste0(
"L'indice de concentration absolue est de ", round(rci_est*100, 2),
" pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), " pp; ", round(rci_up*100, 2), " pp]. ",
"Cela signifie que l'indicateur de santé est concentré chez les plus défavorisés. ",
"En termes absolus, ", abs(round(rci_est*100, 2)), " points de pourcentage de l'indicateur de santé sont concentrés dans les groupes les plus défavorisés, par rapport à un scénario sans différences socioéconomiques."
)
} else if (rci_est > 0 & health_indicator_type == "proportion") {
paste0(
"L'indice de concentration absolue est de ", round(rci_est*100, 2),
" pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), " pp; ", round(rci_up*100, 2), " pp]. ",
"Cela signifie que l'indicateur de santé est concentré chez les plus favorisés. ",
"En termes absolus, ", abs(round(rci_est*100, 2)), " points de pourcentage de l'indicateur de santé sont concentrés dans les groupes les plus favorisés, par rapport à un scénario sans différences socioéconomiques."
)
} else if (rci_est == 0 & health_indicator_type == "proportion") {
paste0(
"L'indice de concentration absolue est de ", round(rci_est*100, 2),
" pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), " pp; ", round(rci_up*100, 2), " pp]. ",
"Cela indique qu'en termes absolus, l'indicateur de santé est réparti équitablement entre les groupes socioéconomiques, sans concentration chez les plus ou les moins défavorisés."
)
}
part_sig_french <- if (rci_low <= 0 & rci_up >= 0) {
paste0(" Cependant, cette concentration n'est pas statistiquement significative.")
} else {
paste0(" De plus, cette concentration est statistiquement significative.")
}
interpretation_french <- paste0(part_main_french, part_sig_french)
note_french <- if (health_indicator_type == "rate") {
paste0(
"Remarque : Les événements correspondent au numérateur de l’indicateur de santé et la population de base au dénominateur. ",
"Par exemple, dans le cas du Taux de mortalité maternelle, les événements seraient les décès maternels et la population de base serait les naissances vivantes."
)
} else {
paste0(
"Remarque : La valeur de l’indicateur de santé correspond à la proportion évaluée. Par exemple : proportion d’accouchements assistés par du personnel qualifié."
)
}
part_main_portuguese <- if (rci_est < 0 & health_indicator_type == "rate") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est, 2),
", ", conf_level*100, "%IC [", round(rci_low, 2), "; ", round(rci_up, 2), "]. ",
"Isso significa que o indicador de saúde está concentrado entre os mais desfavorecidos. ",
"Em termos absolutos, ", abs(round(rci_est, 2)), " eventos por cada ", factor_legible,
" pessoas da população base estão concentrados entre os grupos mais desfavorecidos, em comparação com um cenário sem diferenças socioeconômicas."
)
} else if (rci_est > 0 & health_indicator_type == "rate") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est, 2),
", ", conf_level*100, "%IC [", round(rci_low, 2), "; ", round(rci_up, 2), "]. ",
"Isso significa que o indicador de saúde está concentrado entre os mais favorecidos. ",
"Em termos absolutos, ", abs(round(rci_est, 2)), " eventos por cada ", factor_legible,
" pessoas da população base estão concentrados entre os grupos mais favorecidos, em comparação com um cenário sem diferenças socioeconômicas."
)
} else if (rci_est == 0 & health_indicator_type == "rate") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est*100, 2),
"%, ", conf_level*100, "%IC [", round(rci_low*100, 2), "%; ", round(rci_up*100, 2), "%]. ",
"Isso indica que, em termos absolutos, o indicador de saúde está distribuído de maneira equitativa entre os grupos socioeconômicos, sem se concentrar nem nos mais desfavorecidos nem nos mais favorecidos."
)
} else if (rci_est < 0 & health_indicator_type == "proportion") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est*100, 2),
"pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), "pp; ", round(rci_up*100, 2), "pp]. ",
"Isso significa que o indicador de saúde está concentrado entre os mais desfavorecidos. ",
"Em termos absolutos, ", abs(round(rci_est*100, 2)), " pontos percentuais do indicador de saúde estão concentrados entre os grupos mais desfavorecidos, em comparação com um cenário sem diferenças socioeconômicas."
)
} else if (rci_est > 0 & health_indicator_type == "proportion") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est*100, 2),
"pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), "pp; ", round(rci_up*100, 2), "pp]. ",
"Isso significa que o indicador de saúde está concentrado entre os mais favorecidos. ",
"Em termos absolutos, ", abs(round(rci_est*100, 2)), " pontos percentuais do indicador de saúde estão concentrados entre os grupos mais favorecidos, em comparação com um cenário sem diferenças socioeconômicas."
)
} else if (rci_est == 0 & health_indicator_type == "proportion") {
paste0(
"O Índice de Concentração Absoluta é ", round(rci_est*100, 2),
"pp, ", conf_level*100, "%IC [", round(rci_low*100, 2), "pp; ", round(rci_up*100, 2), "pp]. ",
"Isso indica que, em termos absolutos, o indicador de saúde está distribuído de maneira equitativa entre os grupos socioeconômicos, sem se concentrar nem nos mais desfavorecidos nem nos mais favorecidos."
)
}
part_sig_portuguese <- if (rci_low <= 0 & rci_up >= 0) {
paste0(" No entanto, essa concentração não é estatisticamente significativa.")
} else {
paste0(" Além disso, essa concentração é estatisticamente significativa.")
}
interpretation_portuguese <- paste0(part_main_portuguese, part_sig_portuguese)
note_portuguese <- if (health_indicator_type == "rate") {
paste0(
"Nota: Os eventos correspondem ao numerador do Indicador de Saúde e a população base ao denominador do Indicador de Saúde. ",
"Por exemplo, no caso da Razão de Mortalidade Materna (RMM), os eventos seriam as mortes maternas e a população base seriam os nascidos vivos."
)
} else {
paste0(
"Nota: O valor do Indicador de Saúde corresponde à proporção avaliada. Por exemplo: Proporção de partos assistidos por pessoal qualificado."
)
}
if (language_interpretation == "en") {
interpretation <- interpretation_english
note <- note_english
} else if  (language_interpretation == "es") {
interpretation <- interpretation_spanish
note <- note_spanish
} else if  (language_interpretation == "pt") {
interpretation <- interpretation_portuguese
note <- note_portuguese
} else if  (language_interpretation == "fr") {
interpretation <- interpretation_french
note <- note_french
}
interpretation
results_tbl
note
global_health_mean
View(df)
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
sii?
help(sii)
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help(sii)
healp(ag)
help(ag)
# library(rio)
# #data2 <- import("C:/Documents and Settings/avasquez/Desktop/ejemplo2.xlsx")
#
# #usethis::use_data(data2, overwrite = TRUE)
#
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
# library(rio)
# #data2 <- import("C:/Documents and Settings/avasquez/Desktop/ejemplo2.xlsx")
#
# #usethis::use_data(data2, overwrite = TRUE)
#
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help("ag_luna")
help("man/sii_luna.Rd")
help("man/sii_luna")
help("sii_luna")
devtools::document()
# pkgload::dev_help('aci')
# pkgload::dev_help('aci_luna')
pkgload::dev_help('aci_luna')
devtools::document()
pkgload::dev_help('aci_luna')
devtools::document()
pkgload::dev_help('aci_luna')
devtools::document()
pkgload::dev_help('aci_luna')
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help("aci_luna")
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help("aci_luna")
devtools::document()
pkgload::dev_help('rci_luna')
devtools::document()
pkgload::dev_help('rci_luna')
devtools::document()
pkgload::dev_help('rci_luna')
pkgload::dev_help('aci_luna')
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
install.packages("desc")
desc::desc_validate("DESCRIPTION")
desc::desc_validate("DESCRIPTION")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help("aci_luna")
help("ag")
help("ag_luna")
help("ag_luna")
help("rci_luna")
help("ag_luna")
help("rg_luna")
library(lunaineq)
help("ag_luna")
help("rg_luna")
devtools::document()
devtools::document()
install.packages("xfun")
devtools::document()
devtools::document()
pkgload::dev_help('ag')
pkgload::dev_help('ag_luna')
devtools::install("G:/My Drive/Trabajo/Epidemiologo_Salubrista/OMS/PAHO/2025/lunaineq")
library(lunaineq)
help(ag_luna)
help(rg_luna)
help(rg_luna)
library(lunaineq)
help(rg_luna)
help(ag_luna)
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::install()
devtools::install_github("adrianvas1995/lunaineq", upgrade = "never")
pkgdown::use_pkgdown()
install.packages("pkgdown")
pkgdown::use_pkgdown()
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
file.remove(".git/index.lock")
devtools::document()
devtools::install()
devtools::document()
pkgdown::build_site()
devtools::document()
devtools::document()
View(data1)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
install.packages(c("bookdown", "spelling"))
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
install.packages(cobs)
install.packages("cobs")
# Script de ejemplo: comparar ajustes para función de Lorenz / curva monótona
# Reproducible, con gráficos diagnósticos
# Autor: Para pruebas rápidas (adapte parámetros según su dataset real)
# --- Preparación -----------------------------------------------------------------
set.seed(1234)
library(tibble)
library(dplyr)
library(ggplot2)
library(tidyr)
# Si no tiene 'cobs', descomente e instale:
# install.packages("cobs")
library(cobs)
# --- Crear datos de ejemplo ------------------------------------------------------
# Simulamos una distribución acumulada de población (cwpop) y una "función Lorenz" ruidosa (cwi)
n <- 100
cwpop <- sort(runif(n, 0, 1))
# Curva subyacente (ejemplo): y = x^0.6 (concentración hacia ricos), luego ruido pequeño
true_fun <- cwpop^0.6
cwi <- pmin(pmax(true_fun + rnorm(n, sd = 0.02), 0), 1)
df <- tibble(cwpop = cwpop, cwi = cwi)
# Construir 'nodos' (incluir 0 y 1 como anclas)
nodos <- tibble(cwpop = c(0, df$cwpop, 1),
cwi    = c(0, df$cwi, 1)) %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)   # asegurar unicidad por cwpop
# Puntos de evaluación (los mismos cwpop del df para comparar)
x_eval <- df$cwpop
# --- 1) smooth.spline simple -----------------------------------------------------
# Ajuste estándar (varíe spar o df si desea)
smoothing_factor <- 0.6   # pruebe 0.2, 0.4, 0.6, 0.8
fit_spline <- stats::smooth.spline(x = nodos$cwpop, y = nodos$cwi, spar = smoothing_factor)
pred_spline <- pmin(pmax(stats::predict(fit_spline, x = x_eval)$y, 0), 1)
# --- 2) smooth.spline + isoreg (su flujo actual) ---------------------------------
# Predicción spline, luego imponer monotonicidad con isoreg + approx (su enfoque original)
# (nota: isoreg devuelve valores en los nodos del isoreg; approx interpola linealmente entre ellos)
spline_vals <- stats::predict(fit_spline, x = x_eval)$y
spline_vals <- pmin(pmax(spline_vals, 0), 1)
iso <- stats::isoreg(x_eval, spline_vals)
iso_x <- iso$x
iso_yf <- iso$yf
pred_spline_isoreg <- pmin(pmax(approx(iso_x, iso_yf, xout = x_eval)$y, 0), 1)
# --- 2b) Variante: añadir nodo eps cerca de 0 y reaplicar spline -----------------
# Si el primer cwpop observado está lejos de 0, inserte eps para anclar
min_pos <- min(nodos$cwpop[nodos$cwpop > 0])
eps <- min_pos / 10
eps_val <- approx(nodos$cwpop, nodos$cwi, xout = eps)$y
nodos_eps <- nodos %>%
add_row(cwpop = eps, cwi = eps_val) %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)
fit_spline_eps <- stats::smooth.spline(x = nodos_eps$cwpop, y = nodos_eps$cwi, spar = smoothing_factor)
pred_spline_eps <- pmin(pmax(stats::predict(fit_spline_eps, x = x_eval)$y, 0), 1)
# opcionalmente imponer monotonicidad (si lo desea)
iso_eps <- stats::isoreg(x_eval, pred_spline_eps)
pred_spline_eps_isoreg <- pmin(pmax(approx(iso_eps$x, iso_eps$yf, xout = x_eval)$y, 0), 1)
# --- 3) Ajuste con cobs (B-splines con restricción monotónica) --------------------
# Anclar extremos explícitamente antes del ajuste
nodos_cobs <- nodos %>%
{ if (!0 %in% .$cwpop) add_row(., cwpop = 0, cwi = 0) else . } %>%
{ if (!1 %in% .$cwpop) add_row(., cwpop = 1, cwi = 1) else . } %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)
# Ajuste cobs (ajuste monotónico "increase"). Ajuste nknots según necesidad.
nknots <- 12   # pruebe 8, 12, 20
fit_cobs <- cobs(x = nodos_cobs$cwpop, y = nodos_cobs$cwi, constraint = "increase", nknots = nknots)
pred_cobs <- predict(fit_cobs, z = x_eval)$fit
# -------------------------------------------------------------------------
# Comparación de ajustes para función de Lorenz (smooth.spline vs cobs)
# Script completo reproducible con manejo robusto de predict(cobs)
# -------------------------------------------------------------------------
set.seed(1234)
# --- Paquetes ----------------------------------------------------------------
# Descomente la instalación si necesita instalar 'cobs'
# install.packages(c("tibble", "dplyr", "ggplot2", "tidyr", "cobs"))
library(tibble)
library(dplyr)
library(ggplot2)
library(tidyr)
library(cobs)
# --- Simular datos de ejemplo ------------------------------------------------
n <- 100
cwpop <- sort(runif(n, 0, 1))
true_fun <- cwpop^0.6             # función subyacente de ejemplo
cwi <- pmin(pmax(true_fun + rnorm(n, sd = 0.02), 0), 1)
df <- tibble(cwpop = cwpop, cwi = cwi)
# --- Construir 'nodos' (anclas 0 y 1) ---------------------------------------
nodos <- tibble(cwpop = c(0, df$cwpop, 1),
cwi    = c(0, df$cwi, 1)) %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)
# puntos de evaluación (mismos cwpop)
x_eval <- df$cwpop
# --- 1) smooth.spline simple -------------------------------------------------
smoothing_factor <- 0.6   # experimente 0.2, 0.4, 0.6, 0.8
fit_spline <- stats::smooth.spline(x = nodos$cwpop, y = nodos$cwi, spar = smoothing_factor)
pred_spline <- pmin(pmax(stats::predict(fit_spline, x = x_eval)$y, 0), 1)
# --- 2) smooth.spline + isoreg (flujo original) ------------------------------
spline_vals <- stats::predict(fit_spline, x = x_eval)$y
spline_vals <- pmin(pmax(spline_vals, 0), 1)
iso <- stats::isoreg(x_eval, spline_vals)
iso_x <- iso$x
iso_yf <- iso$yf
pred_spline_isoreg <- pmin(pmax(approx(iso_x, iso_yf, xout = x_eval)$y, 0), 1)
# --- 2b) Variante: insertar nodo eps cerca de 0 y reaplicar spline ----------
# Cuidado si no existen cwpop > 0 (caso extremo)
if (any(nodos$cwpop > 0)) {
min_pos <- min(nodos$cwpop[nodos$cwpop > 0])
eps <- min_pos / 10
eps_val <- approx(nodos$cwpop, nodos$cwi, xout = eps)$y
nodos_eps <- nodos %>%
add_row(cwpop = eps, cwi = eps_val) %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)
fit_spline_eps <- stats::smooth.spline(x = nodos_eps$cwpop, y = nodos_eps$cwi, spar = smoothing_factor)
pred_spline_eps <- pmin(pmax(stats::predict(fit_spline_eps, x = x_eval)$y, 0), 1)
# si desea reinponer monotonicidad también:
iso_eps <- stats::isoreg(x_eval, pred_spline_eps)
pred_spline_eps_isoreg <- pmin(pmax(approx(iso_eps$x, iso_eps$yf, xout = x_eval)$y, 0), 1)
} else {
# Si no hay valores >0 (caso raro), defina variables vacías controladas
min_pos <- NA_real_
eps <- NA_real_
nodos_eps <- nodos
pred_spline_eps <- pred_spline
pred_spline_eps_isoreg <- pred_spline_isoreg
}
# --- 3) Ajuste monotónico con cobs -------------------------------------------
# Anclar extremos si no están presentes (0,0) y (1,1)
nodos_cobs <- nodos %>%
{ if (!0 %in% .$cwpop) add_row(., cwpop = 0, cwi = 0) else . } %>%
{ if (!1 %in% .$cwpop) add_row(., cwpop = 1, cwi = 1) else . } %>%
arrange(cwpop) %>%
distinct(cwpop, .keep_all = TRUE)
nknots <- 12   # pruebe 8, 12, 20 según necesidad
fit_cobs <- cobs(x = nodos_cobs$cwpop, y = nodos_cobs$cwi, constraint = "increase", nknots = nknots)
# --- Predicción robusta desde cobs (múltiples formatos de salida) ------------
res_cobs <- predict(fit_cobs, z = x_eval)
if (is.matrix(res_cobs)) {
# Algunas versiones retornan matrix: columnas típicas (z, fit, ...)
if ("fit" %in% colnames(res_cobs)) {
pred_cobs_raw <- res_cobs[, "fit"]
} else {
pred_cobs_raw <- res_cobs[, ncol(res_cobs)]
}
} else if (is.list(res_cobs) && !is.null(res_cobs$fit)) {
pred_cobs_raw <- res_cobs$fit
} else {
# Si es vector atómico o alguna otra estructura convertible
pred_cobs_raw <- as.numeric(res_cobs)
}
# acotar en [0,1] y asegurar longitud correcta
pred_cobs <- pmin(pmax(pred_cobs_raw, 0), 1)
if (length(pred_cobs) != length(x_eval)) {
stop("La predicción de cobs no coincide en longitud con x_eval.")
}
# --- Preparar tabla para graficar --------------------------------------------
df_plot <- tibble(
cwpop = x_eval,
observed = df$cwi,
spline = pred_spline,
spline_isoreg = pred_spline_isoreg,
spline_eps = pred_spline_eps,
spline_eps_isoreg = pred_spline_eps_isoreg,
cobs = pred_cobs
) %>%
pivot_longer(cols = -cwpop, names_to = "method", values_to = "y")
# nodos para graficar
nodos_plot <- nodos
nodos_eps_plot <- nodos_eps
nodos_cobs_plot <- nodos_cobs
# --- Gráficos comparativos ---------------------------------------------------
p_all <- ggplot() +
geom_point(data = df, aes(x = cwpop, y = cwi), color = "gray40", size = 1.2, alpha = 0.8) +
geom_line(data = df_plot %>% filter(method == "spline"), aes(x = cwpop, y = y, color = "spline"), size = 1) +
geom_line(data = df_plot %>% filter(method == "spline_isoreg"), aes(x = cwpop, y = y, color = "spline_isoreg"), size = 1) +
geom_line(data = df_plot %>% filter(method == "spline_eps_isoreg"), aes(x = cwpop, y = y, color = "spline_eps_isoreg"), size = 1) +
geom_line(data = df_plot %>% filter(method == "cobs"), aes(x = cwpop, y = y, color = "cobs"), size = 1) +
geom_point(data = nodos_plot, aes(x = cwpop, y = cwi), color = "red", size = 1.4) +
scale_color_manual(name = "Método",
values = c(spline = "#1b9e77",
spline_isoreg = "#d95f02",
spline_eps_isoreg = "#7570b3",
cobs = "#e7298a")) +
labs(x = "Población acumulada (cwpop)",
y = "Función Lorenz (acumulada)",
title = "Comparación: smooth.spline / smooth.spline+isoreg (con eps) / cobs") +
theme_minimal(base_size = 12)
# --- Zoom en extremos: 0 -> primer nodo observado -----------------------------
if (!is.na(min_pos)) {
xmax_zoom <- min_pos * 1.1
# calcular ymax razonable en el zoom
ymax_zoom <- max(df$cwi[df$cwpop <= xmax_zoom], na.rm = TRUE) + 0.05
p_zoom <- p_all + coord_cartesian(xlim = c(0, xmax_zoom), ylim = c(0, ymax_zoom))
} else {
p_zoom <- p_all
}
# Mostrar gráficos
print(p_all)
print(p_zoom)
# --- Diagnósticos numéricos: pendientes iniciales -----------------------------
if (!is.na(min_pos)) {
# índice del primer valor observador > 0
first_idx <- which.min(abs(x_eval - min_pos))
idx_zero <- which.min(abs(x_eval - 0))
slope_segment_original <- (df$cwi[first_idx] - 0) / (min_pos - 0)
slope_spline <- (pred_spline[first_idx] - pred_spline[idx_zero]) / (x_eval[first_idx] - x_eval[idx_zero])
slope_cobs <- (pred_cobs[first_idx] - pred_cobs[idx_zero]) / (x_eval[first_idx] - x_eval[idx_zero])
diagnostico <- tibble(
metric = c("slope_segment_original", "slope_spline", "slope_cobs"),
value = c(slope_segment_original, slope_spline, slope_cobs)
)
print(diagnostico)
} else {
message("No hay cwpop > 0 para calcular pendiente inicial (caso extremo).")
}
# --- Guardar / exportar (opcional) -------------------------------------------
# write.csv(df_plot, "ajustes_lorenz_comparacion.csv", row.names = FALSE)
# ggsave("ajuste_lorenz_comparacion.png", p_all, width = 9, height = 5, dpi = 300)
# ggsave("ajuste_lorenz_zoom.png", p_zoom, width = 6, height = 4, dpi = 300)
# -------------------------------------------------------------------------
# Fin del script
# -------------------------------------------------------------------------
devtools::document()
